A heap is a special tree-based data structure in computer science. It is an almost complete binary tree that satisfies the heap property. A complete binary tree is a special type of binary tree in which all the levels are completely filled except possibly the last level, which is filled from left to right.

There are two types of heap:

1. **Max-Heap**: In a max heap, for any given node I, the value of I is greater than or equal to the values of its children. That is, the parent node has a larger value than or equal to both of its child nodes. The key of the root node is the largest among all other nodes.

2. **Min-Heap**: In a min heap, for any given node I, the value of I is less than or equal to the values of its children. That is, the parent node has a smaller value than or equal to both of its child nodes. The key of the root node is the smallest among all other nodes.

Some of the key operations with heaps include:

- **Insertion**: An element can be inserted at the end of the heap (at the bottom-most, right-most position) and then its position is adjusted so that the heap property remains intact. This operation has a time complexity of O(log N) in the worst case.

- **Deletion**: The maximum element (in case of a max heap) or the minimum element (in case of a min heap) can be found at the root of the heap which can be deleted and replaced with the last element in the heap. The position of this new root is then adjusted so that the heap property remains intact. This operation also has a time complexity of O(log N) in the worst case.

- **Heapify**: This operation is used to adjust the position of elements in a heap so that the heap property is maintained. Heapify operation is used during both insertion and deletion operations.

Heaps are used in many algorithms including the heap sort algorithm for sorting data. They are also used in the implementation of priority queues, in Dijkstra's algorithm for finding the shortest path in a graph, and many more.


# MAX Heap


from typing import List, Any


class Heap:
    def __init__(self, a: List[Any] = None):
        self.n = len(a) if a else 0
        self.heap = a if a else []
        self.heapify()

    def heapify(self):
        # start from the latest parent and heapify the input list
        for i in range((self.n - 2) // 2, -1, -1):
            self.bubble_down(self.n, i)

    def bubble_down(self, n, index: int):
        largest = index

        left = 2 * index + 1
        right = 2 * index + 2
        if left < n and self.heap[left] > self.heap[largest]:
            largest = left
        if right < n and self.heap[right] > self.heap[largest]:
            largest = right
        if largest != index:
            self.swap(index, largest)
            self.bubble_down(n, largest)

    def bubble_up(self, index, debug=False):
        parent = index // 2

        if parent >= 0 and self.heap[index] > self.heap[parent]:
            self.swap(index, parent)
            self.bubble_up(parent)

    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def pop(self):
        value = None
        if self.n == 1:
            value = self.heap.pop()
        elif self.n > 1:
            self.swap(0, self.n - 1)
            value = self.heap.pop()
            self.n -= 1
            self.bubble_down(self.n, 0)
        return value

    def get_max(self):
        return self.pop()

    def insert(self, item, debug=False):
        self.heap.append(item)
        self.n += 1
        if self.n > 1:
            self.bubble_up(self.n - 1)

        if debug: print(f"current heap: {self.heap}")

        return self.n

    def sort(self):
        for i in range(self.n - 1, 0, -1):
            self.swap(0, i)
            self.bubble_down(i, 0)

    def get_heap(self):
        return self.heap


def main():
    arr = [1, 6, 3, 5, 8, 4, 7, 2]
    print(f"original arr: {arr}")
    h = Heap(arr)
    h.sort()
    print(f"sorted arr: {arr}")

    # demo pop
    arr = [2, 5, 9, 5, 3, 7, 1]
    h = Heap(arr)
    max_value = h.pop()
    print(f"arr after 1 pop: {arr}")

    # demo empty arr and insertion
    h2 = Heap()
    arr = [2, 5, 9, 5, 3, 7, 1]
    for item in arr:
        h2.insert(item, debug=True)

    heap = h2.get_heap()
    print(f"Final heap after multiple insertions: {heap}")

    # Now sort
    h2.sort()
    sorted_arr = h2.get_heap()
    print(f"Sorted: {sorted_arr}")


if __name__ == "__main__":
    main()


# MIN Heap 

from typing import List, Any

class MinHeap:
    def __init__(self, a: List[Any] = None):
        self.n = len(a) if a else 0
        self.heap = a if a else []
        self.heapify()

    def heapify(self):
        for i in range((self.n - 2) // 2, -1, -1):
            self.bubble_down(self.n, i)

    def bubble_down(self, n, index: int):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < n and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < n and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.swap(index, smallest)
            self.bubble_down(n, smallest)

    def bubble_up(self, index):
        parent = (index - 1) // 2
        if parent >= 0 and self.heap[index] < self.heap[parent]:
            self.swap(index, parent)
            self.bubble_up(parent)

    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def pop(self):
        value = None
        if self.n == 1:
            value = self.heap.pop()
        elif self.n > 1:
            self.swap(0, self.n - 1)
            value = self.heap.pop()
            self.n -= 1
            self.bubble_down(self.n, 0)
        return value

    def get_min(self):
        return self.pop()

    def insert(self, item):
        self.heap.append(item)
        self.n += 1
        if self.n > 1:
            self.bubble_up(self.n - 1)

    def sort(self):
        for i in range(self.n - 1, 0, -1):
            self.swap(0, i)
            self.bubble_down(i, 0)

    def get_heap(self):
        return self.heap

def main():
    arr = [1, 6, 3, 5, 8, 4, 7, 2]
    print(f"original arr: {arr}")
    h = MinHeap(arr)
    h.sort()
    print(f"sorted arr: {arr}")

    arr = [2, 5, 9, 5, 3, 7, 1]
    h = MinHeap(arr)
    min_value = h.pop()
    print(f"arr after 1 pop: {arr}")

    h2 = MinHeap()
    arr = [2, 5, 9, 5, 3, 7, 1]
    for item in arr:
        h2.insert(item)

    heap = h2.get_heap()
    print(f"Final heap after multiple insertions: {heap}")

    h2.sort()
    sorted_arr = h2.get_heap()
    print(f"Sorted: {sorted_arr}")

if __name__ == "__main__":
    main()